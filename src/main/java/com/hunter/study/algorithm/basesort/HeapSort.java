package com.hunter.study.algorithm.basesort;import com.hunter.study.algorithm.SortUtil;import org.junit.Test;import java.util.Arrays;/** * @Author 水木 * 堆排序 * @Date 2021/3/30  2:39 下午 */public class HeapSort {	public int[] sort(int[] arr) {		if (arr.length <= 0) {			return arr;		}		//先把数组搞成大根堆		for (int i = arr.length - 1; i >= 0; i--) {			heapify(arr, i, arr.length);		}		//将数组中的第一个和最后一个交换位置		for (int i = arr.length - 1; i >= 1; i--) {			SortUtil.swapInArray(arr, 0, i);			heapify(arr, 0, i);		}		return arr;	}	/**	 * 对于每一个有子孩子的父节点，用父节点的值和左右孩子较大的值比较，	 * 如果父节点值大，则退出，如果小则下沉，并将index的值改为下沉到的index,继续循环比较	 *	 * @param arr	 * @param index    数组中的下标	 * @param heapSize 需要做堆排序的大小	 */	public void heapify(int[] arr, int index, int heapSize) {		int left = index * 2 + 1;		//如果没有超出数组的长度，则进行循环		while (left < heapSize) {			int right = left + 1;			//取出左右孩子中较大的孩子的下标			int largestIndex = (right < heapSize && arr[right] > arr[left]) ? right : left;			//再和父节点比较，取较大者的下标			largestIndex = arr[index] > arr[largestIndex] ? index : largestIndex;			if (largestIndex == index) {				break;			}			//如果孩子节点值大，则进行下沉			SortUtil.swapInArray(arr, index, largestIndex);			index = largestIndex;			left = largestIndex * 2 + 1;		}	}	@Test	public void testSort() {		int max = 100;		for (int i = 0; i < max; i++) {			final int[] before = SortUtil.generateRandomArray(5, 10);//			final int[] before = new int[]{-1, -1, -1, 0};			System.out.println("==========第" + i + 1 + "组=========");			System.out.println("before=" + Arrays.toString(before));			//			insertionSort(before);			sort(before);			System.out.println("after=" + Arrays.toString(before));		}////		int[] test=new int[]{2, 3, -5, 4, 0};//		quickSort1(test);	}}