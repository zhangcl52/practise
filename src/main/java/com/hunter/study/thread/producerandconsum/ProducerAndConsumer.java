package com.hunter.study.thread.producerandconsum;import java.util.concurrent.locks.Condition;import java.util.concurrent.locks.Lock;import java.util.concurrent.locks.ReentrantLock;/** * 生产者多线程、消费者多线程、每个线程只生产或只消费一个数据 * 生产者线程内部需要同步、消费者线程内部需要同步、生产者线程和消费者线程需要同步 * 生产一个时,如果有阻塞的消费线程则去唤醒一个消费线程 * 消费一个时,如果有阻塞的生产线程则去唤醒一个生产线程 * 多体会lock的用法 * @Author zhangcl * @Date 17/2/6  下午9:27 */public class ProducerAndConsumer {    //现在有的资源数量(临界资源)    private int i = 0;    //最大生产数量    private int max = 2;    private Lock lock = new ReentrantLock();    private Condition condition1 = lock.newCondition();    private Condition condition2 = lock.newCondition();    /**     * main 方法     *     * @param args     */    public static void main(String[] args) {        //开启的线程数        int totalThread = 50;        ProducerAndConsumer producerAndConsumer = new ProducerAndConsumer();        Producer producer = producerAndConsumer.new Producer();        Consumer consumer = producerAndConsumer.new Consumer();        for (int i = 0; i < totalThread; i++) {            Thread thread = new Thread(producer);            thread.start();        }        for (int i = 0; i < totalThread; i++) {            Thread thread = new Thread(consumer);            thread.start();        }    }    /**     * 生产者     */    private class Producer implements Runnable {        @Override        public void run() {            this.produce();        }        private void produce() {            //获取锁            lock.lock();            /**             * 当同时有因为await而阻塞的线程A,和还未获取过锁的线程B时             * 而此时i=max-1同时B获取到了锁,那么B执行完后时i=max,此时A又获取了锁,这时需要重新做i==max的判断,             * 如果不做判断,那么i=max+1了,从而超出了最大值             */            while(true){                //当生产满时,生产线程进入阻塞                if (i == max) {                    try {                        System.out.println(Thread.currentThread().getName() + "生产进入等待");                        condition1.await();                    } catch (Exception e) {                    }                }else {                    break;                }            }            i++;            System.out.println(Thread.currentThread().getName() + " 生产 " + i);            condition2.signal();            lock.unlock();        }    }    /**     * 消费     */    private class Consumer implements Runnable {        @Override        public void run() {            this.consume();        }        private void consume() {            lock.lock();            while (true){                if (i == 0) {                    try {                        System.out.println(Thread.currentThread().getName() + "消费进入等待");                        condition2.await();                    } catch (Exception e) {                    }                }else{                    break;                }            }            System.out.println(Thread.currentThread().getName() + " 消费 " + i);            i--;            condition1.signal();            lock.unlock();        }    }}