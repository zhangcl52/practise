package com.hunter.study.leetcode;/** * @Author 水木 * @Date 2021/2/24  10:43 下午 */public class FindMedianSortedArrays {	/**	 * 寻找两个正序数组的中位数	 *	 * 自己写的，已验证（正确）---逻辑复杂，边界情况较多	 *	 * @param nums1	 * @param nums2	 * @return	 */	public double findMedianSortedArrays(int[] nums1, int[] nums2) {		boolean isJishu = (nums1.length + nums2.length) % 2 != 0 ? true : false;		int mid = (nums1.length + nums2.length) >> 1;		if (mid == 0) {			return nums1.length == 1 ? nums1[0] : nums2[0];		}		int nums1Index = -1;		int nums2Index = -1;		for (int i = 0; i < nums1.length + nums2.length; i++) {			if (nums1Index + 1 >= nums1.length) {				nums2Index++;			} else if (nums2Index + 1 >= nums2.length) {				nums1Index++;			} else if (nums1[nums1Index + 1] < nums2[nums2Index + 1]) {				nums1Index++;			} else {				nums2Index++;			}			if (isJishu && i == mid) {				if (nums1Index == -1) {					return nums2[nums2Index];				} else if (nums2Index == -1) {					return nums1[nums1Index];				} else {					return Math.max(nums1[nums1Index], nums2[nums2Index]);				}			}			if (!isJishu && i == mid - 1) {				int first = 0;				if (nums1Index == -1) {					first = nums2[nums2Index];				} else if (nums2Index == -1) {					first = nums1[nums1Index];				} else {					first = Math.max(nums1[nums1Index], nums2[nums2Index]);				}				int second = 0;				if (nums1Index == nums1.length - 1) {					second = nums2[nums2Index + 1];				} else if (nums2Index == nums2.length - 1) {					second = nums1[nums1Index + 1];				} else {					second = Math.min(nums2[nums2Index + 1], nums1[nums1Index + 1]);				}				return (first + second) / 2.0;			}		}		return 0;	}}