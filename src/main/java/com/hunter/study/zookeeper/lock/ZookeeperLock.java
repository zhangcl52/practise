package com.hunter.study.zookeeper.lock;import com.hunter.study.common.ZookeeperConstant;import lombok.extern.slf4j.Slf4j;import org.apache.curator.framework.CuratorFramework;import org.apache.curator.framework.CuratorFrameworkFactory;import org.apache.curator.retry.ExponentialBackoffRetry;import org.apache.zookeeper.CreateMode;import org.apache.zookeeper.WatchedEvent;import org.apache.zookeeper.Watcher;import org.apache.zookeeper.data.Stat;import java.util.concurrent.CountDownLatch;/** * @Author zhangcl * @Date 18/7/25  上午8:57 */@Slf4jpublic class ZookeeperLock {    public static CuratorFramework client;    private static final String X_LOCK = "x_lock";    private ZookeeperLock() {    }    static {        client = CuratorFrameworkFactory.builder()                .namespace(ZookeeperConstant.NAMESPACE)                .connectString(ZookeeperConstant.SERVER_LIST)                .sessionTimeoutMs(ZookeeperConstant.SESSION_TIMEOUT_MS)                .connectionTimeoutMs(ZookeeperConstant.CONNECTION_TIMEOUT_MS)                .retryPolicy(new ExponentialBackoffRetry(                        1000, 16, 60000))                .build();    }    /**     * 生成一个节点的排他锁     *     * @param name     */    public static void Lock(String name) {        String path = X_LOCK + "/" + name;        CountDownLatch countDownLatch = new CountDownLatch(1);        //如果锁失败，则需要监听这个节点是否被删除        if (!tryLock(name, path)) {            try {                client.start();                Stat stat = client.checkExists().forPath(path);                if (stat == null) {                    tryLock(name, path);                } else {                    client.getData().usingWatcher(new Watcher() {                        @Override                        public void process(WatchedEvent event) {                            if (event.getType().equals(Event.EventType.NodeDeleted)) {                                countDownLatch.countDown();                            }                        }                    });                    countDownLatch.await();                    tryLock(name, path);                }            } catch (Exception e) {                log.error("lock error", e);            } finally {                client.close();            }        }    }    /**     * 尝试去锁     *     * @param name     * @return     */    private static boolean tryLock(String name, String path) {        try {            client.start();            Stat stat = client.checkExists().forPath(path);            if (stat != null) {                return false;            }            client.create().creatingParentsIfNeeded().withMode(CreateMode.EPHEMERAL)                    .forPath(X_LOCK + name);        } catch (Exception e) {            log.error("tryLock error", e);            return false;        } finally {            client.close();        }        return true;    }    /**     * 释放锁     *     * @param name     */    private void unLock(String name) {        String path = X_LOCK + "/" + name;        try {            client.start();            Stat stat = client.checkExists().forPath(path);            if (stat != null) {                client.delete().forPath(path);            }        } catch (Exception e) {            log.error("unLock error", e);        } finally {            client.close();        }    }}