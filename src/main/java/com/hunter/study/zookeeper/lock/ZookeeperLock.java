package com.hunter.study.zookeeper.lock;import com.hunter.study.common.Constant;import com.hunter.study.common.ZookeeperConstant;import lombok.extern.slf4j.Slf4j;import org.apache.curator.framework.CuratorFramework;import org.apache.curator.framework.CuratorFrameworkFactory;import org.apache.curator.retry.ExponentialBackoffRetry;import org.apache.zookeeper.CreateMode;import org.apache.zookeeper.KeeperException;import org.apache.zookeeper.WatchedEvent;import org.apache.zookeeper.Watcher;import org.apache.zookeeper.data.Stat;import java.util.concurrent.CountDownLatch;/** * @Author zhangcl * @Date 18/7/25  上午8:57 */@Slf4jpublic class ZookeeperLock {    private CuratorFramework client;    private static final String X_LOCK = "/lock/x_lock";    public ZookeeperLock() {        client = CuratorFrameworkFactory.builder()                .namespace(ZookeeperConstant.NAMESPACE)                .connectString(ZookeeperConstant.SERVER_LIST)                .sessionTimeoutMs(ZookeeperConstant.SESSION_TIMEOUT_MS)                .connectionTimeoutMs(ZookeeperConstant.CONNECTION_TIMEOUT_MS)                .retryPolicy(new ExponentialBackoffRetry(                        1000, 16, 60000))                .build();        client.start();    }    /**     * 生成一个节点的排他锁     *     * @param name     */    public void lock(String name) {        String path = X_LOCK + Constant.ZK_SEP + name;        CountDownLatch countDownLatch = new CountDownLatch(1);        if (!tryLock(path)) {            try {                Stat stat = client.checkExists().forPath(path);                //监听删除事件                if (stat != null) {                    try{                        client.getData().usingWatcher(new Watcher() {                            @Override                            public void process(WatchedEvent event) {                                if (event.getType().equals(Event.EventType.NodeDeleted)) {                                    //唤醒                                    countDownLatch.countDown();                                }                            }                        }).forPath(path);                        //线程阻塞                        countDownLatch.await();                    }catch (KeeperException.NoNodeException e){                        //获取锁                        lock(name);                    }                }                //获取锁                lock(name);            } catch (Exception e) {                log.error("lock error", e);            }        }    }    /**     * 尝试去锁     *     * @param path     * @return     */    private boolean tryLock(String path) {        try {            client.create().creatingParentsIfNeeded().withMode(CreateMode.EPHEMERAL)                    .forPath(path);        } catch (Exception e) {            return false;        }        return true;    }    /**     * 释放锁     *     * @param name     */    public void unLock(String name) {        String path = X_LOCK + Constant.ZK_SEP + name;        try {            Stat stat = client.checkExists().forPath(path);            if (stat != null) {                client.delete().forPath(path);            }        } catch (Exception e) {            log.error("unLock error", e);        }    }    public static void main(String[] args) {//        ZookeeperLock.Lock("testLock");        ZookeeperLock zookeeperLock = new ZookeeperLock();        zookeeperLock.lock("1212");    }}